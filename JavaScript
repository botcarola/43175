Documentación adjunta de las clases de la cursada

Clase 0: Introducción

¿Qué es una página web?

Es un documento el cual puede ser accedido a través de un navegador web. Está compuesto por diversos elementos, como texto, imágenes, enlaces, videos, FORMULARIOS, entre otros, que se combinan para proporcionar información y funcionalidad a los usuarios.

Las páginas web están escritas en lenguajes de marcado, como HTML, que define la estructura y contenido básicos y CSS, que se encarga de establecer el aspecto visual y la presentación de la página.

Cuando un usuario ingresa la dirección de una página web en un navegador web, el navegador envía una solicitud al servidor donde se aloja la página. El servidor procesa la solicitud y envía la págiba web al navegador, que la intrepreta y la muestra al usuario.

Las páginas web pueden ser estáticas o dinámicas. Las páginas estáticas son aquellas cuyo contenido no cambia, a menos que se realice una actualización manual del código fuente. Por otro lado, las páginas dinámicas se generan en tiempo real, a partir de una base de datos u otras fuentes de información, lo que permite mostrar contenido actualizado y personalizado para cada usuario.

Páginas web dinámicas y estáticas: definición, características y ejemplos:

Estáticas

EJ:  

Una página web estática es aquella que no permite la interración con el usuario para modificar el contenido del documento. Esn este tipo de páginas la información mostrada siempre es la misma y su actualización depende de una modificación del código.

Características de sitios web estáticos:

- Son escasamente interactivos: Estas páginas no ofrecen un margen de libertad a los usuarios para actualizar o modificar sus contenidos. Estrictamente el contenido de una página web es fijo y no cambia.

- Su funcionamiento depende de una programación definida: Las páginas precisan de la intregración de un código en HTML que contenga la información a presentar y uno en CSS que le dé formato al sitio.

- Requieren intervención humana: Debido a que tienen contenidos que no cambian de forma automática, la actualización de la información debe llevarla a cabo de manera manual el programador o diseñador.


Dinámicas:

Una página web dinámica es un sitio en línea que permite la interacción con el usuario para crear experiencias personalizadas y únicas. Los contenidos de una página web dinámica varían con cada carga para ofrecer actualizaciones en tiempo real y ajustarse a las necesidades del visitante.

Características de las páginas web dinámicas:

- Son altamente interactivas: Estos sitios ofrecen a los visitantes la posibilidad de interactuar con los contenidos del sitio. Esto se puede llevar a cabo a través de formularios, herramientas interactivas o recursos multimedia disponibles para la navegación. El contenido de una web dinámica dependerá en gran medida de las acciones que lleve a cabo el usuario en ella. EJ: carrito de compra, envío de formulario, etc.

- Su funcionamiento depende de comandos: Teniendo en cuenta que los contenidos que se despliegan en este tipos de páginas web están sujetos a la interacción con el visitante, es necesario que la plataforma esté programada para darle un buen margen de libertad. Los programadores deben optimizar el sitio con JavaScript para que se generen los cambios esperados en el sitio dependiendo de las acciones del usuario.

- Permiten la automatización: Debido a que estos sitios requieren una constante actualización, es importante incluir recursos que permitan llevar a cabo muchas tareas de forma automática. Esto es posible con una programación que involucre tu base de datos con el código que permite el funcionamiento de la página. Esto es importante cuando hablamos de sitios de comercio electrónico, en donde será necesario que los datos que se presentan en una página correspondan a los de la disponibilidad de un producto o de los costos actualizados de tu mercancía. Al automatizar procesos requerirás una mínica interacción humana que podrás reservar a la actualización de los contenidos fijos que se despliegan en el sitio.

----------------------------------

¿Qué es una aplicación web?

Una aplicación web es una aplicación interactiva que se accede a través de un navegador web. A diferencia de las aplicaciones de escritorio que se instalan en un dispositivo local, las aplicaciones web se ejecutan en un servidor remoto y se entregan al usuario a través de Internet. Esto significa que los usuarios pueden acceder a la aplicación web desde cualquier dispositivo con un navegador y conexión a Internet, sin necesidad de instalar software adicional.

Las aplicaciones web pueden ser muy diversas en términos de funcionalidad y complejidad. Pueden ofrecer características similares a las aplicaciones de escritorio, como la manipulación de bases de datos, la gestión de archivos, el procesamiento de pagos y la interacción en tiempo real. Algunos ejemplos comunes de aplicaciones web son las redes sociales, los servicios de correo electrónico, los sistemas de gestión de contenido y los sistemas de comercio electrónico.

-----------------------------------

¿Qué es un lenguaje de programación? 

Un lenguaje de programación es un lenguaje formal (o artificial, es decir, un lenguaje con reglas gramaticales bien definidas) que proporciona a una persona, en este caso al programador, la capacidad y habilidad de escribir (o programar) una serie de instrucciones o secuencias de órdenes en forma de algoritmos con el fin de controlar el comportamiento físico o lógico de un sistema informático, para que de esa manera se puedan obtener diversas clases de datos o ejecutar determinadas tareas. A todo este conjunto de órdenes escritas mediante un lenguaje de programación se le denomina programa informático.

¿Qué es un intérprete o interpretador?

En ciencias de la computación, intérprete o interpretador es un programa informático capaz de analizar y ejecutar otros programas. Los intérpretes se diferencian de los compiladores o de los ensambladores en que mientras estos traducen un programa desde su descripción en un lenguaje de programación al código de máquina del sistema, los intérpretes solo realizan la traducción a medida que sea necesaria, típicamente, instrucción por instrucción, y normalmente no guardan el resultado de dicha traducción.

Los programas interpretados suelen ser más lentos que los compilados debido a la necesidad de traducir el programa mientras se ejecuta, pero a cambio son más flexibles como entornos de programación y depuración (lo que se traduce, por ejemplo, en una mayor facilidad para reemplazar partes enteras del programa o añadir módulos completamente nuevos), y permiten ofrecer al programa interpretado un entorno no dependiente de la máquina donde se ejecuta el intérprete, sino del propio intérprete (lo que se conoce comúnmente como máquina virtual).

Para mejorar el desempeño, algunas implementaciones de algunos lenguajes de programación pueden interpretar o compilar el código fuente original en una forma intermedia más compacta, y después traducir eso al código de máquina (ej. Perl, Python, MATLAB, y Ruby). Algunos aceptan los archivos fuente guardados en esta representación intermedia (ej. Python, UCSD Pascal y Java).

En la actualidad, uno de los entornos más comunes de uso de los intérpretes es en los navegadores web, debido a la posibilidad que estos tienen de ejecutarse independientemente de la plataforma.

Entonces, ¿Qué es JavaScript?

JavaScript (abreviado comúnmente JS) es un lenguaje de programación interpretado, dialecto del estándar ECMAScript. Se define como orientado a objetos, basado en prototipos, imperativo, débilmente tipado y dinámico.

Se utiliza principalmente del lado del cliente, implementado como parte de un navegador web permitiendo mejoras en la interfaz de usuario y páginas web dinámicas y JavaScript del lado del servidor (Server-side JavaScript o SSJS). Su uso en aplicaciones externas a la web, por ejemplo en documentos PDF, aplicaciones de escritorio (mayoritariamente widgets) es también significativo.

Desde 2012, todos los navegadores modernos soportan completamente ECMAScript 5.1, una versión de JavaScript. Los navegadores más antiguos soportan por lo menos ECMAScript 3. La sexta edición se liberó en julio de 2015.4

JavaScript se diseñó con una sintaxis similar a C++ y Java, aunque adopta nombres y convenciones del lenguaje de programación Java. Sin embargo, Java y JavaScript tienen semánticas y propósitos diferentes. Su relación es puramente comercial, tras la compra del creador de Java (Sun Microsystems) de Netscape Navigator (creador de LiveScript) y el cambio de nombre del lenguaje de programación.

Todos los navegadores modernos interpretan el código JavaScript integrado en las páginas web. Para interactuar con una página web se provee al lenguaje JavaScript de una implementación del Document Object Model (DOM). Javascript es el único lenguaje de programación que entienden de forma nativa los navegadores.

Tradicionalmente se venía utilizando en páginas web HTML para realizar operaciones y únicamente en el marco de la aplicación cliente, sin acceso a funciones del servidor. Actualmente es ampliamente utilizado para enviar y recibir información del servidor junto con ayuda de otras tecnologías como AJAX. JavaScript se interpreta en el agente de usuario al mismo tiempo que las sentencias van descargándose junto con el código HTML.

Desde el lanzamiento en junio de 1997 del estándar ECMAScript 1, han existido las versiones 2, 3 y 5, que es la más usada actualmente (la 4 se abandonó). En junio de 2015 se cerró y publicó la versión ECMAScript 6.

---------------------------------------------

CLASE 1: INTRODUCCIÓN A JAVASCRIPT

En el contexto de la programación, los datos son información que usamos en nuestros programas informáticos. Por ejemplo, tu nombre de usuario en Twitter es un dato.

Gran parte de la programación se trata de manipular o mostrar datos. Para hacer esto, los programadores necesitamos alguna manera de guardar y registrar datos.

¿Para qué queremos guardarlos? Porque necesitamos reutilizarlos. Precisamos de una manera de referirnos a este dato en particular para que podamos hacer uso nuevamente de ello, a lo largo de nuestro programa.

Entonces las variables no son más que un espacio de memoria reservado para alojar un tipo de dato. Es un contenedor que no solo preserva un dato, sino que también le otorga un nombre, para poder señalarlo y luego utilizarlo.

-----------------

¿Qué son las variables? 

Una variable es un recurso de memoria reservado para alojar una información. Son muy útiles e imprescindibles para la programación. Si un lenguaje no tiene variables muy probablemente no es un lenguaje de programación sino uno de marcado como el html o «descriptivo» como el CSS.

Las variables tienen un continente que puede o no almacenar un contenido. El continente es imprescindible. El contenido es optativo.

EJEMPLO:

let edad;

Esto sería la declaración de un recurso de memoria (variable) llamado edad. El punto y coma recordar que es optativo y que indica fin de instrucción. Esta variable de momento tiene el valor undefined (no existe). Javascript reserva el espacio pero todavía no sabe que información contiene.

Una vez declarada una variable ya no puede volverse a declarar con el mismo nombre. (a excepción de que sea una variable local dentro de una función) El navegador ya habrá reservado recursos para ese nombre de variable determinado y si lo volviéramos a declarar daría un error.

Ej:

let edad;

let edad;

ERROR, NO SE PUEDE, SE INTERRUMPE LA EJECUCIÓN. Esto sucede porque comparten el mismo espacio, es decir, no pueden declararse dos variables con el mismo nombre, pero si REASIGNARSE.

A continuación podemos usar el signo (=) para hacer una asignación de valor a la variable. O también podemos optar por no hacer esta asignación y entonces la variable continua almacenando el valor «undefined«.

let edad;

edad = 30;

edad = 50;

edad = 1000;

Esto es correcto :D

Reasignar significa atribuirle un nuevo valor a la variable. Esto significa que puedo modificar los datos que contiene sin limitaciones, pero esto depende de qué manera declaremos la variable. En este caso, si no queremos que el valor sea alterado, deberemos utilizar la palabra reservada const y asignar el valor, ya que esta no puede guardar un valor undefined.

Ej:

const nombre = "Carola";

ERRORES:

const apellido = "Lala";

apellido = "Lele";

ERROR, ESTO ES REASIGNAR, CAMBIAR SU VALOR, CONST ES CONSTANTE !!!!

Habiendo aclarado esto, podemos concluir que JavaScript nos ofrece dos formas de declarar variables, una con let, que puede reasignar su valor todas las veces que sean necesarias y otra con const, que va a guardar y preservar ese valor, sin mutarlo. 

LET Y CONST
Para profundizar…

Let previene la sobreescritura accidental de variables.

Const prohíbe la reasignación de valores a variables.


------------------------------------------------

SINTAXIS BÁSICA DE JavaScript

La sintaxis de JavaScript es muy similar a la de otros lenguajes de programación como Java y C. Las normas básicas que definen la sintaxis de JavaScript son las siguientes:

- No se tienen en cuenta los espacios en blanco y las nuevas líneas: como sucede con XHTML, el intérprete de JavaScript ignora cualquier espacio en blanco sobrante, por lo que el código se puede ordenar de forma adecuada para entenderlo mejor (tabulando las líneas, añadiendo espacios, creando nuevas líneas, etc.)

- Se distinguen las mayúsculas y minúsculas: al igual que sucede con la sintaxis de las etiquetas y elementos XHTML. Sin embargo, si en una página XHTML se utilizan indistintamente mayúsculas y minúsculas, la página se visualiza correctamente, siendo el único problema la no validación de la página. En cambio, si en JavaScript se intercambian mayúsculas y minúsculas el script no funciona.

- No se define el tipo de las variables: al crear una variable, no es necesario indicar el tipo de dato que almacenará. De esta forma, una misma variable puede almacenar diferentes tipos de datos durante la ejecución del script.

- No es necesario terminar cada sentencia con el carácter de punto y coma (;): en la mayoría de lenguajes de programación, es obligatorio terminar cada sentencia con el carácter ;. Aunque JavaScript no obliga a hacerlo, es conveniente seguir la tradición de terminar cada sentencia con el carácter del punto y coma (;).

- Se pueden incluir comentarios: los comentarios se utilizan para añadir información en el código fuente del programa. Aunque el contenido de los comentarios no se visualiza por pantalla, si que se envía al navegador del usuario junto con el resto del script, por lo que es necesario extremar las precauciones sobre la información incluida en los comentarios.

------------------------------------------

TIPOS DE DATOS

Un valor en JavaScript siempre pertenece a un tipo de dato determinado. Por ejemplo, un string o un número.

Podemos almacenar un valor de cualquier tipo dentro de una variable. Por ejemplo, una variable puede contener en un momento un string y luego almacenar un número:

// no hay error
let message = "hola";
message = 123456;

Los lenguajes de programación que permiten estas cosas, como JavaScript, se denominan “dinámicamente tipados”, lo que significa que allí hay tipos de datos, pero las variables no están vinculadas rígidamente a ninguno de ellos.

NUMBER

El tipo number representa tanto números enteros como de punto flotante.

let n = 123;
n = 12.345;

Hay muchas operaciones para números. Por ejemplo, multiplicación *, división /, suma +, resta -, y demás.

Además de los números comunes, existen los llamados “valores numéricos especiales” que también pertenecen a este tipo de datos: Infinity, -Infinity y NaN.

Infinity representa el Infinito matemático ∞. Es un valor especial que es mayor que cualquier número.

Hacer matemáticas es “seguro” en JavaScript. Podemos hacer cualquier cosa: dividir por cero, tratar las cadenas no numéricas como números, etc.

El script nunca se detendrá con un error fatal (“morir”). En el peor de los casos, obtendremos NaN como resultado.


console.log("20" + 10) '2010'
console.log(typeof (20 + "03213")) 'string'
console.log("29" * 20) 580
console.log(2000 / "3") 666.6666666666666
console.log(200 * "asd") NaN
console.log("30" - "30") 0

STRING

Un string en JavaScript es una cadena de caracteres y debe colocarse entre comillas. Los caracteres representan letras del abecedario, signos de puntuación y otros símbolos.

let str = "Hola";
let str2 = 'Las comillas simples también están bien';
let phrase = `se puede incrustar otro ${str}`;

En JavaScript, hay 3 tipos de comillas.

Comillas dobles: "Hola".
Comillas simples: 'Hola'.
Backticks (comillas invertidas): `Hola`.
Las comillas dobles y simples son comillas “sencillas” (es decir, funcionan igual). No hay diferencia entre ellas en JavaScript.

Los backticks son comillas de “funcionalidad extendida”. Nos permiten incrustar variables y expresiones en una cadena de caracteres encerrándolas en ${...}, por ejemplo:

let name = "John";

// incrustar una variable
alert( `Hola, ${name}!` ); // Hola, John!

// incrustar una expresión
alert( `el resultado es ${1 + 2}` ); //el resultado es 3

La expresión dentro de ${...} se evalúa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ahí dentro: una variable como name, una expresión aritmética como 1 + 2, o algo más complejo.

Toma en cuenta que esto sólo se puede hacer con los backticks. ¡Las otras comillas no tienen esta capacidad de incrustación!

----------------------------------------------------


ALERT, PROMPT Y CONFIRM

Como usaremos el navegador como nuestro entorno de demostración, veamos un par de funciones para interactuar con el usuario: alert, prompt, y confirm.

alert
Ya la hemos visto. Muestra un mensaje y espera a que el usuario presione “Aceptar”.

Por ejemplo:

alert("Hello");

La mini ventana con el mensaje se llama * ventana modal *. La palabra “modal” significa que el visitante no puede interactuar con el resto de la página, presionar otros botones, etc., hasta que se haya ocupado de la ventana. En este caso, hasta que presionen “OK”.

La función prompt acepta dos argumentos:

result = prompt(title, [default]);
Muestra una ventana modal con un mensaje de texto, un campo de entrada para el visitante y los botones OK/CANCELAR.

title
El texto a mostrar al usuario.

default
Un segundo parámetro opcional, es el valor inicial del campo de entrada.

El usuario puede escribir algo en el campo de entrada de solicitud y presionar OK, así obtenemos ese texto en result. O puede cancelar la entrada, con el botón “Cancelar” o presionando la tecla Esc, de este modo se obtiene null en result.

La llamada a prompt retorna el texto del campo de entrada o null si la entrada fue cancelada.

Por ejemplo:

let age = prompt ('¿Cuántos años tienes?', 100);

alert(`Tienes ${age} años!`); //Tienes 100 años!

confirm
La sintaxis:

result = confirm(pregunta);
La función confirm muestra una ventana modal con una pregunta y dos botones: OK y CANCELAR.

El resultado es true si se pulsa OK y false en caso contrario.

Por ejemplo:

let isBoss = confirm("¿Eres el jefe?");

alert( isBoss ); // true si se pulsa OK

______________________________________________________________________________

INFO ADICIONAL ANTES DEL TEMA DE LA CLASE

VALORES VACÍOS 

Existen dos valores especiales, escritos como null y undefined, que son usados para denotar la ausencia de un valor significativo. Son en si mismos valores, pero no traen consigo información.

Muchas operaciones en el lenguaje que no producen un valor significativo, producen undefined simplemente porque tienen que producir algún valor.

NULL 

El valor especial null no pertenece a ninguno de los tipos de datos existentes.

Forma un tipo propio separado que contiene sólo el valor null:

let gustoDeHelado = null;

En JavaScript, null no es una “referencia a un objeto inexistente” o un “puntero nulo” como en otros lenguajes.

Es sólo un valor especial que representa “nada”, “vacío” o “valor desconocido”.

El código anterior indica que el valor de gustoDeHelado es desconocido o está vacío por alguna razón.

UNDEFINED

El valor especial undefined también se distingue. Hace un tipo propio, igual que null.

El significado de undefined es “valor no asignado”.

Si una variable es declarada, pero no asignada, entonces su valor es undefined:

let edad;

alert(edad); // muestra "undefined"

Técnicamente, es posible asignar undefined a cualquier variable:

let esEstudiante = undefined;

…Pero no recomendamos hacer eso. Normalmente, usamos null para asignar un valor “vacío” o “desconocido” a una variable, mientras undefined es un valor inicial reservado para cosas que no han sido asignadas.

ADEMÁS null es un valor que es permitido en la transmisión de datos, en cambio undefined no lo es.

-------------------------------

CLASE 2: CONTROL DE FLUJO

Es frecuentemente útil tener un valro que distingue entre solo dos posibilidades, como "si" y "no", "encendido" y "apagado". Para este propósito, JavaScript tiene el tipo BOOLEAN, que tiene solo dos valores: true (verdadero) y false (falso) que se escriben de la misma forma.

Ejemplos:

const encendido = true;
const apagado = false;

Los valores booleanos también son el resultado de comparaciones:

let isGreater = 4 > 1;

alert( isGreater ); // verdadero (el resultado de la comparación es "sí")

Ahondaré más al respecto luego.

VALORES FALSOS EN JAVASCRIPT

Un valor falso es algo que se evalúa como false, por ejemplo, cuando se comprueba una variable. Solo hay ser valores falsos en JavaScript:

undefined, null, NaN, 0 y "" (cadena vacía) y false por supuesto.

OPERADORES DE COMPARACIÓN

Conocemos muchos operadores de comparación de las matemáticas:

- Mayor/menor que: a > b, a < b.

- Mayor/menor o igual que: a >= b, a <= b.

- Igual: a == b (ten en cuenta que el doble signo == significa comparación, mientras que un solo símbolo a = b significaría una asignación).
Distinto. En matemáticas la notación es ≠, pero en JavaScript se escribe como una asignación con un signo de exclamación delante: a != b.

BOOLEANO ES EL RESULTADO

Como todos los demás operadores, una comparación retorna un valor. En este caso, el valor es un booleano.

true – significa “sí”, “correcto” o “verdad”.
false – significa “no”, “equivocado” o " no verdad".

Entonces:

console.log( 2 > 1 ) ---> true
console.log( 2 == 1 ) ---> false
console.log( 2 != 1 ) ---> true

El resultado de una comparación puede asignarse a una variable, igual que cualquier valor:

let result = 5 > 4; // asignar el resultado de la comparación
alert( result ); // true

UNA COMPARACIÓN GRACIOSA 

Es posible que al mismo tiempo:

Dos valores sean iguales.
Uno de ellos sea true como booleano y el otro sea false como booleano.
Por ejemplo:

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert( a == b ); // true!
Desde el punto de vista de JavaScript, este resultado es bastante normal. Una comparación de igualdad convierte valores utilizando la conversión numérica (de ahí que "0" se convierta en 0), mientras que la conversión explícita Boolean utiliza otro conjunto de reglas.

IGUALDAD ESTRICTA

Una comparación regular de igualdad == tiene un problema. No puede diferenciar 0 de `falso’:

alert( 0 == false ); // true
Lo mismo sucede con una cadena vacía:

alert( '' == false ); // true

Esto sucede porque los operandos de diferentes tipos son convertidos a números por el operador de igualdad ==. Una cadena vacía, al igual que false, se convierte en un cero.

¿Qué hacer si queremos diferenciar 0 de false?

Un operador de igualdad estricto === comprueba la igualdad sin conversión de tipo.

En otras palabras, si a y b son de diferentes tipos, entonces a === b retorna inmediatamente false sin intentar convertirlos.

Intentémoslo:

alert( 0 === false ); // falso, porque los tipos son diferentes
Existe también un operador de “diferencia estricta” !== análogo a !=.

El operador de igualdad estricta es un poco más largo de escribir, pero hace obvio lo que está pasando y deja menos espacio a errores.

COMPARACIÓN CON NULOS E INDEFINIDOS 

Veamos más casos extremos.

Hay un comportamiento no intuitivo cuando se compara null o undefined con otros valores.

Para un control de igualdad estricto ===
Estos valores son diferentes, porque cada uno de ellos es de un tipo diferente.

alert( null === undefined ); // false
Para una comparación no estricta ==
Hay una regla especial. Estos dos son una " pareja dulce ": son iguales entre sí (en el sentido de ==), pero no a ningún otro valor.

alert( null == undefined ); // true

Para matemáticas y otras comparaciones < > <= >=
null/undefined se convierten en números: null se convierte en 0, mientras que undefined se convierte en NaN.

---------------------------------------------

OPERADORES LÓGICOS

Hay cuatro operadores lógicos en JavaScript: || (O), && (Y), ! (NO), ?? (Fusión de nulos).

Aunque sean llamados lógicos, pueden ser aplicados a valores de cualquier tipo, no solo booleanos. EL RESULTADO PUEDE SER DE CUALQUIER TIPO

|| (OR)
El operador OR se representa con dos símbolos de linea vertical:

result = a || b;
En la programación clásica, el OR lógico esta pensado para manipular solo valores booleanos. Si cualquiera de sus argumentos es true, retorna true, de lo contrario retorna false.

En JavaScript, el operador es un poco más complicado y poderoso. Pero primero, veamos qué pasa con los valores booleanos.

Hay cuatro combinaciones lógicas posibles:

alert(true || true); // true (verdadero)
alert(false || true); // true
alert(true || false); // true
alert(false || false); // false (falso)

Como podemos ver, el resultado es siempre true excepto cuando ambos operandos son false.

Si un operando no es un booleano, se lo convierte a booleano para la evaluación.

Por ejemplo, el número 1 es tratado como true, el número 0 como false:

if (1 || 0) { // Funciona como if( true || false )
  alert("valor verdadero!");
}

La mayoría de las veces, OR || es usado en una declaración if para probar si alguna de las condiciones dadas es true.

Por ejemplo:

let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'La oficina esta cerrada.' );
}
Podemos pasar mas condiciones:

let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert("La oficina esta cerrada."); // Es fin de semana
}

&& (AND)
El operador AND es representado con dos ampersands &&:

result = a && b;
En la programación clásica, AND retorna true si ambos operandos son valores verdaderos y false en cualquier otro caso.

alert(true && true); // true
alert(false && true); // false
alert(true && false); // false
alert(false && false); // false
Un ejemplo con if:

let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert("La hora es 12:30");
}
Al igual que con OR, cualquier valor es permitido como operando de AND:

if (1 && 0) { // evaluado como true && false
  alert( "no funcionará porque el resultado es un valor falso" );
}

! (NOT)
El operador booleano NOT se representa con un signo de exclamación !.

La sintaxis es bastante simple:

result = !value;
El operador acepta un solo argumento y realiza lo siguiente:

Convierte el operando al tipo booleano: true/false.
Retorna el valor contrario.
Por ejemplo:

alert(!true); // false
alert(!0); // true
Un doble NOT !! es a veces usado para convertir un valor al tipo booleano:

alert(!!"cadena de texto no vacía"); // true
alert(!!null); // false
Eso es, el primer NOT convierte el valor a booleano y retorna el inverso, y el segundo NOT lo invierte de nuevo. Al final, tenemos una simple conversión a booleano.

Hay una manera un poco mas prolija de realizar lo mismo – una función integrada Boolean:

alert(Boolean("cadena de texto no vacía")); // true
alert(Boolean(null)); // false
La precedencia de NOT ! es la mayor de todos los operadores lógicos, así que siempre se ejecuta primero, antes que && o ||.

---------------------------------------

Ejecución condicional: if, '?'
A veces necesitamos que, bajo condiciones diferentes, se ejecuten acciones diferentes.

Para esto podemos usar la sentencia if y el “operador condicional” ?.

La sentencia “if”
La sentencia if(...) evalúa la condición en los paréntesis, y si el resultado es verdadero (true), ejecuta un bloque de código.

Por ejemplo:

let year = prompt('¿En que año fué publicada la especificación ECMAScript-2015?', '');

if (year == 2015) alert( '¡Estás en lo cierto!' );
Aquí la condición es una simple igualdad (year == 2015), pero podría ser mucho más compleja.

Si queremos ejecutar más de una sentencia, debemos encerrar nuestro bloque de código entre llaves:

if (year == 2015) {
  alert( "¡Es Correcto!" );
  alert( "¡Eres muy inteligente!" );
}

Recomendamos encerrar nuestro bloque de código entre llaves {} siempre que se utilice la sentencia if, incluso si solo se va a ejecutar una sola sentencia. Al hacerlo mejoramos la legibilidad.

Conversión Booleana
La sentencia if (…) evalúa la expresión dentro de sus paréntesis y convierte el resultado en booleano.

Recordemos las reglas de conversión del capítulo Conversiones de Tipos:

El número 0, un string vacío "", null, undefined, y NaN, se convierten en false. Por esto son llamados valores “falsos”.
El resto de los valores se convierten en true, entonces los llamaremos valores “verdaderos”.
Entonces, el código bajo esta condición nunca se ejecutaría:

if (0) { // 0 es falso
  ...
}
…y dentro de esta condición siempre se ejecutará:

if (1) { // 1 es verdadero
  ...
}
También podemos pasar un valor booleano pre-evaluado al if, así:

let cond = (year == 2015); // la igualdad evalúa y devuelve un true o false

if (cond) {
  ...
}
La cláusula “else”
La sentencia if puede contener un bloque else (“si no”, “en caso contrario”) opcional. Este bloque se ejecutará cuando la condición sea falsa.

Por ejemplo:

let year = prompt('¿En qué año fue publicada la especificación ECMAScript-2015?', '');

if (year == 2015) {
  alert( '¡Lo adivinaste, correcto!' );
} else {
  alert( '¿Cómo puedes estar tan equivocado?' ); // cualquier valor excepto 2015
}
Muchas condiciones: “else if”
A veces queremos probar más de una condición. La clausula else if nos permite hacer esto.

Por ejemplo:

let year = prompt('¿En qué año fue publicada la especificación ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Muy poco...' );
} else if (year > 2015) {
  alert( 'Muy Tarde' );
} else {
  alert( '¡Exactamente!' );
}
En el código de arriba, JavaScript primero revisa si year < 2015. Si esto es falso, continúa a la siguiente condición year > 2015. Si esta también es falsa, mostrará la última alert.

Podría haber más bloques else if. Y el último else es opcional.

_____________________________________________________________________

CLASE 3 | BUCLES 

Una de las principales ventajas de la programación es la posibilidad de crear bucles y repeticiones para tareas específicas, y que no tengamos que realizar el mismo código varias veces de forma manual.

Los bucles nos permiten sumplificar nuestro código, que sea más fácil de leer e incluso más fácil de modificar y mantener.

CONDICIÓN

Al igual que en los condicionales if, en los bucles se va a evaluar una condición para saber si se debe seguir repitiendo el bucle o se debe finalizar. Habitualmente, lo que se suele hacer es establecer que si la condición es verdadera, se vuelve a repetir el bucle. Por el contratio, si es falsa, se finaliza. Sin embargo, esta condición puede variar dependiendo de la implementación que le indique el programador.

ITERACIÓN

Otro concepto que usaremos mucho dentro de un bucle es el concepto de iteración. Esto se refuere a cada una de las repeticiones de un bucle. 

INCREMENTO

Al igual que tenemos un contador en un bucle, también debemos tener una parte donde hagamos un incremento (o decremento) de dicho contador. Si no lo tuvieramos, el contador no cambiaría y la condición síempre sería verdadera, por lo que sería imposible salir del bucle.

BUCLE INFINITO

Cuando estamos aprendiendo a programar, es muy común que cometamos un error creando el bucle y nos quedemos en un bucle infinito, es decir, en una situación donde nuestro programa se queda eternamiente en bucle y nunca termina. Como programadores, esta situación siempre hay que evitarla. Para ello, lo que debemos hacer es siempre comprobar que existe un incremento (o decremento) y que en algún momento la condición va a ser falsa y se podrá salir del bucle.

- Tener en cuenta que de producirse un bucle infinito, nuestro programa se uqedará atascado y tendremos que forzar para finalizarlo. Ten siempre cuidado al crear un bucle para que no sea infinito. -


for loop

Sintaxis

for ([initializacion]); [condicion]; [expresion-final]) {
   // sentencias
}

La sentencia for en javascript consiste de tres expresiones y una declaración:

- inicialización - Sucede antes de la primera ejecución del bucle. Esta expresión es comúnmente utilizada para crear contadores. Las variables creadas tienen un alcance (scope) limitado al cuerpo del bucle. Una vez que el bucle ha terminado su ejecución las variables son destruidas.

- condición - Expresión que es evaluada antes de la ejecución de cada iteración. Si se omite, esta expresión es evaluada como verdadera. Si devuelve true, la sentencia del cuerpo del bucle se ejecuta. Si devuelve false, el bucle se detiene.

- expresión-final - Expresión que se ejecuta luego de cada iteración. Usualmente es utilizada para incrementar un contador. Pero también puede ser utilizada para decrementar el contador.

- sentencia o declaración - Código que será ejecutado repetidamente por el bucle.

Cualquiera de estas tres expresiones o la sentencia del cuerpo del bucle pueden ser omitidas. Los bucles For son comúnmente utilizados para contar un cierto número de iteraciones para repetir una sentencia. Puedes utilizar una sentencia break para salir del bucle antes que la expresión de condición devuelva false.

EJEMPLO

for (i=1;i<=6;i++) { 
    // document.write("<H" + i + ">Encabezado de nivel " + i + "</H" + i + ">") 
    document.write(`<h2>Este es el encabezado ${i}</h2>`)
}

while loop

El bucle while empieza por evaluar la condición. Si la condición es verdadera (devuelve true), entonces las sentencias son ejecutadas. Si la condición es falsa (devuelve false), entonces las sentencias no son ejecutadas. Luego el bucle finaliza.

Aquí la sintaxis del bucle while:

Sintaxis:

while (condicion)

{

  sentencia(s);

}

- sentencia(s): Una sentencia es código que se ejecuta si la condición devuelve verdadero ( true ).

- condición: Es una expresión booleana (Boolean) que es evaluada antes de cada paso (iteración) por el bucle. Si esta condición evalúa a verdadero ( true ), las sentencias son ejecutadas. Cuando la condición evalúa a falso ( false ), la ejecución continúa con la siguiente sentencia luego del bucle while.

EJEMPLO

let i = 0;
while (i < 3) { // muestra 0, luego 1, luego 2
  alert( i );
  i++;
}




La sentencia "switch"

Una sentencia switch puede reemplazar múltiples condiciones if.

Provee una mejor manera de comparar un valor con múltiples variantes.

switch(x) {
  case 'valor1':  // if (x === 'valor1')
    ...
    [break]

  case 'valor2':  // if (x === 'valor2')
    ...
    [break]

  default:
    ...
    [break]
}

EJEMPLO

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Muy pequeño' );
    break;
  case 4:
    alert( '¡Exacto!' );
    break;
  case 5:
    alert( 'Muy grande' );
    break;
  default:
    alert( "Desconozco estos valores" );
}

Aquí el switch inicia comparando a con la primera variante case que es 3. La comparación falla.

Luego 4. La comparación es exitosa, por tanto la ejecución empieza desde case 4 hasta el break más cercano.

Si no existe break entonces la ejecución continúa con el próximo case sin ninguna revisión.

Agrupamiento de “case”
Varias variantes de case los cuales comparten el mismo código pueden ser agrupadas.

Por ejemplo, si queremos que se ejecute el mismo código para case 3 y case 5:

let a = 2 + 2;

switch (a) {
  case 4:
    alert('¡Correcto!');
    break;

  case 3:                    // (*) agrupando dos cases
  case 5:
    alert('¡Incorrecto!');
    alert("¿Por qué no tomas una clase de matemáticas?");
    break;

  default:
    alert('El resultado es extraño. Realmente.');
}

TAREA: SOBREESCRIBIR EL SIGUIENTE SWITCH EN IF

switch (navegador) {
  case 'Edge':
    alert( "¡Tienes Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Esta bien, soportamos estos navegadores también' );
    break;

  default:
    alert( '¡Esperamos que esta página se vea bien!' );
}

--------------------------------------------------------------------------

CLASE 4: FUNCIONES 

Las funciones son bloques de código que solucionan un problema específico para ser reutilizados. Existen dos tipos de funciones: declarativas y expresivas.

Ya hemos visto ejemplos de funciones integradas, como alert(message), prompt(message, default) y confirm(question). Pero también podemos crear funciones propias.

QUÉ SON LAS FUNCIONES DECLARATIVAS?

- En JavaScript, las funciones declarativas se las declara con la palabra reservada function.

CÓMO DECLARAR UNA FUNCIÓN DECLARATIA?

- La declaración de una función declarativa está constituido por las siguientes partes:

* La palabra reservada function.
* El nombre de la función: el cual será guardado como referencia en memoria.
* Los parámetros: están envueltas en paréntesis (), son variables propias de la función y deberán utilizarse en el contenido. Hacen referencia a los argumentos en la invocación.
* El contenido: está envuelto por llaves {}, contendrá las líneas de código correspondientes a la lógica del problema.
* El valor retornado: es un único valor que devuelve la función cuando es llamada. Se lo especifica por la palabra reservada return. Si no existe, la función devolverá un valor undefined por defecto.

SINTAXIS

/* 
function nombre (parámetros) {
    contenido
    return valor
} 
*/


EJEMPLO

// Declaración
function suma (a,b){
    return a + b
}


De esta manera, definimos la lógica de la función, pero no la estamos utilizando. Para generar los valores es necesario invocar la función en el código según sea necesario.

CÓMO INVOCAR UNA FUNCIÓN DECLARATIVA?

La invocación o llamada es la manera que utilizamos las funciones para utilizar el valor de retorno (return) según ciertos argumentos. La invocación de la función declarativa está constituido por dos partes:

- El nombre de la función especificada en la declaración.
- Los argumentos, son los valores para cada uno de parámetros de la función envueltos entre paréntesis.

EJEMPLO

// Invocación
suma(2,3)
// nombre(argumentos)

La invocación sirve para emplear una función con diferentes argumentos y guardarlos en una variable.

const resultado1 = suma(2,3)
const resultado2 = suma(4,6)
const resultado3 = suma(10,12)

console.log(resultado1) //5
console.log(resultado2) //10
console.log(resultado3) //22

También existen funciones que simplemente se invocan, pero debes tener en cuenta que retornan por defecto undefined.

// Declaración
function saludar(nombre){
    console.log("Hola " + nombre) 
}
// Invocaciones
saludar("JavaScript") //"Hola JavaScript"
saludar("Carola") // "Hola Carola"

QUÉ SON LAS FUNCIONES EXPRESIVAS O ANÓNIMAS

Las funciones expresivas o anónimas consisten en guardar la función en una variable. Tienen la misma declaración e invocación que las funciones declarativas. La diferencia consiste en no especificar un nombre en la función, sino que utiliza el nombre de la variable.

// Declaración
var suma = function (a, b) {
  return a + b
}
// Invocación
var resultado = suma(2, 2)

console.log(resultado) //4


DIFERENCIA ENTRE UNA FUNCIÓN CON NOMBRE Y UNA ANÓNIMA 

- Cuando declaramos una función anónima no puede ser procesada hasta que el intérprete llegue a donde está declarada. El navegador va leyendo la página de arriba abajo, entonces la llamada a la función anónima debe estar siempre más abajo.

- En cambio, si se trata de una función con nombre, el intérprete lo primero que hace es buscar las declaraciones las variables y funciones que puedan existir. Después comienza a leer línea por línea. De modo que podemos poner la llamada a una función antes de que ésta haya sido declarada.

ÁMBITO DE LAS VARIABLES 

Las variables que se declaran dentro de una función sólo existen durante la ejecución de esa función. Son variables locales. Aunque exista otra variable con el mismo nombre fuera de la función, una no modifia a la otra.

EJ

function fechaHoy() {
    //fecha es una variable local de la función
    const fecha = new Date();
    return fecha;
}

También podemos utilizar una variable global dentro de una función y que los cambios que se hagan afecten a la misma.

let diaDeHoy;

function fechaHoy() {
    //fecha es una variable local de la función
    const fecha = new Date();
    diaDeHoy = fecha;
};

console.log(diaDeHoy) ---> mostrará la fecha actual

VARIABLES GLOBALES 

- Variables declaradas fuera de cualquier función, como la variable diaDeHoy en el código anterior, se llaman globales.

- Las variables globales son visibles desde cualquier función (a menos que se les superpongan variables locales con el mismo nombre).

Es una buena práctica reducir el uso de variables globales. El código moderno tiene pocas o ninguna variable global. La mayoría de las variables residen en sus funciones. Aunque a veces puede justificarse almacenar algunos datos a nivel de proyecto.

FUNCIONES FLECHA

Hay otra sintaxis muy simple y concisa para crear funciones, que a menudo es mejor que las Expresiones de funciones.

Se llama “funciones de flecha”, porque se ve así:

const func = (arg1, arg2, ..., argN) => expression;

Esto crea una función func que acepta los parámetros arg1..argN, luego evalúa la expression del lado derecho mediante su uso y devuelve su resultado.

En otras palabras, es la versión más corta de:

let func = function(arg1, arg2, ..., argN) {
  return expression;
};

let sum = (a, b) => a + b;

/* Esta función de flecha es una forma más corta de:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3

Como puedes ver, (a, b) => a + b significa una función que acepta dos argumentos llamados a y b. Tras la ejecución, evalúa la expresión a + b y devuelve el resultado.

Si solo tenemos un argumento, se pueden omitir paréntesis alrededor de los parámetros, lo que lo hace aún más corto.

Por ejemplo:

let double = n => n * 2;
// Más o menos lo mismo que: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
Si no hay parámetros, los paréntesis estarán vacíos; pero deben estar presentes:

let sayHi = () => alert("¡Hola!");

sayHi();
Las funciones de flecha se pueden usar de la misma manera que las expresiones de función.

Por ejemplo, para crear dinámicamente una función:

let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('¡Hola!') :
  () => alert("¡Saludos!");

welcome();
Las funciones de flecha pueden parecer desconocidas y poco legibles al principio, pero eso cambia rápidamente a medida que los ojos se acostumbran a la estructura.

Son muy convenientes para acciones simples de una línea, cuando somos demasiado flojos para escribir muchas palabras.

_______________________________________________________________________________

CLASE 5: OBJETOS 

Los números, los booleanos y los strings son los átomos que constituyen las
estructuras de datos. Sin embargo, muchos tipos de información requieren más de un átomo. Los objetos nos permiten agrupar valores—incluidos otros objetos— para construir estructuras más complejas.

Los programas que hemos construido hasta ahora han estado limitados por el hecho de que estaban operando solo en tipos de datos simples.

Como aprendimos hay ocho tipos de datos en JavaScript. Siete de ellos se denominan “primitivos”, porque sus valores contienen solo un dato (sea un string, un número o lo que sea).

En contraste, los objetos son usados para almacenar colecciones de varios datos y entidades más complejas asociados con un nombre clave. En JavaScript, los objetos penetran casi todos los aspectos del lenguaje. Por lo tanto, debemos comprenderlos primero antes de profundizar en cualquier otro lugar.

Podemos crear un objeto usando las llaves {…} con una lista opcional de propiedades. Una propiedad es un par “key:value”, donde key es un string (también llamado “nombre clave”), y value puede ser cualquier cosa. 
Para fines prácticos de la lección, nos referiremos a este par de conceptos como “clave:valor”.

let user = new Object(); // sintaxis de "constructor de objetos"
let user = {};  // sintaxis de "objeto literal"

- Normalmente se utilizan las llaves {...}. Esa declaración se llama objeto literal.

- Podemos poner inmediatamente algunas propiedades dentro de {...} como pares “clave:valor”:

let user = {     // un objeto
  name: "John",  // En la clave "name" se almacena el valor "John"
  age: 30        // En la clave "age" se almacena el valor 30
};

- Una propiedad tiene una clave (también conocida como “nombre” o “identificador”) antes de los dos puntos ":" y un valor a la derecha.

- En el objeto user hay dos propiedades:

* La primera propiedad tiene la clave "name" y el valor "John".
* La segunda tienen la clave "age" y el valor 30.

TAMBIÉN PODEMOS AGREGAR, ELIMINAR Y LEER ARCHIVOS DE ÉL EN CUALQUIER MOMENTO

- Se puede acceder a los valores de las propiedades utilizando la notación de punto.

// Obteniendo los valores de las propiedades del objeto:
alert( user.name ); // John
alert( user.age ); // 30

- El valor puede ser de cualquier tipo. Agreguemos uno booleano:

user.isAdmin = true;

- Para eliminar una propiedad podemos usar el operador delete:

delete user.age;

- También podemos nombrar propiedades con más de una palabra. Pero, de ser así, debemos colocar la clave entre comillas "...":

let user = {
  name: "John",
  age: 30,
  "likes birds": true  // Las claves con más de una palabra deben ir entre comillas
};

- La última propiedad en la lista puede terminar con una coma:

let user = {
  name: "John",
  age: 30,
}

- Eso se llama una coma “final” o “colgante”. Facilita agregar, eliminar y mover propiedades, porque todas las líneas se vuelven similares.

CORCHETES

- La notación de punto no funciona para acceder a propiedades con claves de más de una palabra:

// Esto nos daría un error de sintaxis
user.likes birds = true

- JavaScript no entiende eso. Piensa que hemos accedido a user.likes y entonces nos da un error de sintaxis cuando aparece el inesperado birds.

- El punto requiere que la clave sea un identificador de variable válido. Eso implica que: no contenga espacios, no comience con un dígito y no incluya caracteres especiales ($ y _ sí se permiten).

- Existe una “notación de corchetes” alternativa que funciona con cualquier string:

let user = {};

// asignando
user["likes birds"] = true;

// obteniendo
alert(user["likes birds"]); // true

// eliminando
delete user["likes birds"];

Ahora todo está bien. Nota que el string dentro de los corchetes está adecuadamente entre comillas (cualquier tipo de comillas servirían).

Los corchetes también brindan una forma de obtener el nombre de la propiedad desde el resultado de una expresión (a diferencia de la cadena literal). Por ejemplo, a través de una variable:

let key = "likes birds";

// Tal cual: user["likes birds"] = true;
user[key] = true;

- Aquí la variable key puede calcularse en tiempo de ejecución o depender de la entrada del usuario y luego lo usamos para acceder a la propiedad. Eso nos da mucha flexibilidad.

Por ejemplo:

let user = {
  name: "John",
  age: 30
};

let key = prompt("¿Qué te gustaría saber acerca del usuario?", "name");

// acceso por medio de una variable
alert( user[key] ); // John (si se ingresara "name")

- La notación de punto no puede ser usada de manera similar:

let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined

____________________________________________________________________

CLASE 6: ARRAY

Los objetos te permiten almacenar colecciones de datos a través de nombres. Eso está bien.

Pero a menudo necesitamos una colección ordenada, donde tenemos un 1ro, un 2do, un 3er elemento y así sucesivamente. Por ejemplo, necesitamos almacenar una lista de algo: usuarios, bienes, elementos HTML, etc.

No es conveniente usar objetos aquí, porque no proveen métodos para manejar el orden de los elementos. No podemos insertar una nueva propiedad “entre” los existentes. Los objetos no están hechos para eso.

Existe una estructura llamada Array (llamada en español arreglo o matriz/vector) para almacenar colecciones ordenadas.

QUÉ ES UN ARRAY?

- Un array es una colección o agrupación de elementos en una misma variable, cada uno de ellos ubicado por la posición que ocpa en el array. En algunas ocasiones también se les suelen llamar arreglos o vectores. En JavaScript, se pueden definir de varias formas:

Con el constructor new Array:

// Forma tradicional (no se suele usar en Javascript)
const letters = new Array("a", "b", "c");   // Array con 3 elementos
const letters = new Array(3);               // Array vacío de tamaño 3

// Mediante literales (notación preferida)
const letters = ["a", "b", "c"];  // Array con 3 elementos
const letters = [];               // Array vacío (0 elementos)
const letters = ["a", 5, true];   // Array mixto (String, Number, Boolean)

- Al contrario que muchos otros lenguajes de programación, Javascript permite que se puedan realizar arrays de tipo mixto, no siendo obligatorio que todos los elementos sean del mismo tipo de dato.

OJO: Al crear un array con new Array(size) hay varios matices que merece la pena mencionar. Lo primero, si sólo se indica un parámetro numérico size, Javascript creará un array vacío de size elementos. Es decir, no es lo mismo que const a = [3], donde creamos un array con un elemento 3. Por otro lado, new Array(size) realmente crea un array vacío que aún no ha sido rellenado con nada (esto hace que sea más óptimo para arrays grandes) y aunque es equivalente, no es exactamente igual new Array(3) que [undefined, undefined, undefined].

ACCESO A ELEMENTOS DEL ARRAY

Al igual que los string, saber el número elementos que tiene un array es muy sencillo. Sólo hay que acceder a la propiedad .length, que nos devolverá el número de elementos existentes en un array:

EJ:

const frutas = [ "banana", "manzana", "naranja"]

frutas.length ---> 3

OPERADOR []

Por otro lado, si lo que queremos es acceder a un elemento específico del array, no hay más que utilizar el operador [], al igual que lo podríamos hacer con los STRINGS para acceder a un carácter concreto. En este caso, accedemos a la posición del elemento que queremos recuperar sobre el array:

const letters = ["a", "b", "c"];

letters.length;   // 3
letters[0];       // 'a'
letters[2];       // 'c'
letters[5];       // undefined

Recuerda que las posiciones empiezan a contar desde 0 y que si intentamos acceder a una posición que no existe (mayor del tamaño del array), nos devolverá un undefined.

El operador [] no sólo nos permite obtener o acceder a un elemento del array, sino que también nos permite modificar un elemento específico del array, si utilizamos la asignación:

const letters =  ["a", "b", "c"];

letters[1] = "Z";  // Devuelve "Z" y modifica letters a ["a", "Z", "c"]
letters[3] = "D";  // Devuelve "D" y modifica letters a ["a", "Z", "c", "D"]
letters[5] = "A";  // Devuelve "A" y modifica letters a ["a", "Z", "c", "D", undefined, 

Ten en cuenta que con el nuevo método .with(), se puede hacer esto de una forma más cómoda y sin modificar el array original. Permite encadenar múltiples operaciones, pero ten en cuenta que sólo modifica, no se pueden añadir elementos que no existen antes en el array:

const letters =  ["a", "b", "c"];

letters.with(1, "Z");   // Devuelve "Z" y modifica letters a ["a", "Z", "c"]
letters.with(1, "Z")
       .with(3, "D");   // No se puede hacer porque la posición 3 no existe
letters.with(5, "A");   // No se puede hacer porque la posición 5 no existe


El método .at()

Además del clásico operador [], también podemos utilizar el método .at(), añadido en Javascript ES2022. Con él, se puede hacer exactamente lo mismo que con [pos], sólo que además permite valores negativos, mediante los cuales se puede obtener elementos en orden inverso, es decir, empezando a contar desde el último elemento:

const letters = ["a", "b", "c"];

letters.at(0);    // "a"
letters.at(1);    // "b"
letters.at(3);    // undefined
letters.at(-1);   // "c"
letters.at(-2);   // "b"

Esta característica hace que acceder al último elemento (o cercanos) sea bastante práctico, ya que hacer la misma operación con el operador [] era algo menos directo que en algunos casos se podría volver confuso o poco intuitivo:

const letters = ["a", "b", "c"];
const lastItem = letters.length - 1;

letters[lastItem];    // "c"

_________________________________________________________________________________

CLASE 7: FUNCIONES DE ORDEN SUPERIOR

Las funciones son un concepto muy importante en JavaScript. Dominarlas es una necesidad.

Recapitulando, ¿Qué es una función?

Es necesario pensarlas como palabras en nuestro lenguaje. Diferentes vocabularios nos ayudan a evitar repetir las mismas palabras. Por ejemplo, en lugar de decir "una persona entre 13 y 19 años", podemos utilizar el término adolescente. Esto nos proporciona la libertad de usar esta palabra para formar diferentes oraciones sin generar confusiones.

Las funciones siguen un patrón similar, nos permiten envolver un programa completo en una sola expresión (que en este caso se alojaría bajo un identificador). Entonces podemos llamar a esta expresión como nuestro nuevo vocabulario. Luego podemos utilizarla en cualquier parte de nuestro código para hacer cosas diferentes.

EJEMPLO

// Esta es el nuevo vocabulario o expresión, que resume la operación suma
// Dentro de esta función, se combinan parámetros y operadores, para dar lugar a un nuevo resultado
// Esta función retorna un nuevo valor, a partir de valores anteriores
// La función suma no existía antes en JavaScript, pero nosotros hemos creado una nueva expresión, extendiendo el vocabulario de JavaScript
// Ahora JavaScript puede realizar esta nueva "abstracción" llamada suma.

const suma = ( a, b ) => a + b

// Podemos usar esta suma para muchas cosas, como por ejemplo calcular el salario neto y el aguinaldo

const totalSalarioYAguinaldo = ( a, b ) => {
  return suma(a, b)
}

console.log(totalSalarioYAguinaldo(100000, 50000)) // 150000

// Podemos usar esta suma para hacer una calculadora

const restar = ( a ,  b ) => a - b
const dividir = ( a, b ) => a / b
const multiplicar = ( a, b ) => a * b

const calculadora = ( a , b, operacion ) => {
  return operacion(a, b)
}

console.log( calculadora(10, 10, multiplicar))
console.log( calculadora(123213213, 100000000, dividir))


// Podemos usar la función suma, para calcular lo que sea

if ( suma(10, 100) % 2 === 0 ){
  console.log("Es número par")
} else {
  console.log("Es número impar")
}

ENTONCES

- La capacidad de envolver una lógica en una sola expresión es muy poderoso.

- Puede hacer que nuestro código sea legible y fácilmente mantenible

- En caso de que tengamos que hacer cambios, podemos hacerlo en un solo lugar, el lugar donde definimos lo que debe hacer la función y no dónde la usamos.

- Las funciones nos ayudan a evitar la repetición. Definimos una vez y la usamos en diferentes contextos. Esto puede salvarnos de muchos errores.

PERO, ¿A QUÉ VIENE TODO ESTO? 

Pensémoslo desde otra perspectiva. Supongamos que debemos desarrollar el algoritmo calculadora y este se aloja en su totalidad en una sola función. Este programa grande será muy costoso  y no solo por el tiempo, sino por la complejidad que va a involucrar y eso puede generar, como consecuencia, mucha confusión. 

Las confusiones generan errores y proporcionan espacio a que los bugs se desarrollen.

PREVENGAMOS CON ABSTRACCIÓN

- En el contexto de la programación, la idea de separar o aislar la lógica de un algoritmo en funciones más pequeñas y especializadas a la resolución de una tarea, son llamadas abstracciones.

- Las abstracciones esconden los detalles y nos dan la capacidad de hablar acerca de los problemas a un nivel superior.

* Como una analogía, compara estas dos recetas de sopa de guisantes:

Coloque 1 taza de guisantes secos por persona en un recipiente. Agregue agua hasta que los guisantes esten bien cubiertos. Deje los guisantes en agua durante al menos 12 horas. Saque los guisantes del agua y pongalos en una cacerola para cocinar. Agregue 4 tazas de agua por persona. Cubra la sartén y mantenga los guisantes hirviendo a fuego lento durante dos horas. Tome media cebolla por persona. Cortela en piezas con un cuchillo. Agréguela a los guisantes. Tome un tallo de apio por persona. Cortelo en pedazos con un cuchillo. Agréguelo a los guisantes. Tome una zanahoria por persona. Cortela en pedazos. Con un cuchillo! Agregarla a los guisantes. Cocine por 10 minutos más.

* Y la segunda receta:

Por persona: 1 taza de guisantes secos, media cebolla picada, un tallo de apio y una zanahoria.

Remoje los guisantes durante 12 horas. Cocine a fuego lento durante 2 horas en 4 tazas de agua (por persona). Picar y agregar verduras. Cocine por 10 minutos más.

- La segunda receta es más corta y fácil de interpretar. Pero necesitas entender algunas palabras más relacionadas a la cocina -remojar, cocinar a fuego lento, picar, etc-

- Cuando programamos, no podemos confiar en que todas las palabras que necesitaremos estarán esperando por nosotros en el diccionario.

- Por ello, debemos ir desarrollando cada concepto ( cada abstrácción ), para ampliar este "vocabulario" y así generar una abstracción más alta.

FUNCIONES DE PRIMERA CLASE

A todo esto, en ningún momento nos preguntamos cómo es que podemos manipular funciones así como así. 

Se dice que se tienen "Funciones de primera clase" cuando las funciones en ese lenguaje son tratadas como cualquier otra variable.

- Entonces en JavaScript una función puede ser pasada como argumento a otras funciones.

- Puede ser retornada por otra función

- Puede ser asignada a una variable (funciones por expresión)

DOCUMENTACIÓN: https://developer.mozilla.org/es/docs/Glossary/First-class_Function

FUNCIONES DE ORDEN SUPERIOR

Las funciones que operan en otras funciones, ya sea tomándolas como argumentos o retornándolas, se denominan funciones de orden superior.

- Esta característica es incorporada frecuentemente en los lenguajes de programación funcional

Como ya hemos visto que las funciones son valores regulares, no existe nada particularmente notable sobre el hecho de que tales funciones existen. El término proviene de las matemáticas, donde la distinción entre funciones y otros valores se toma más en serio.

Las funciones de orden superior nos permiten abstraer sobre acciones, no solo sobre valores. Estas vienen en varias formas. Por ejemplo:

- Podemos crear funciones que crean nuevas funciones

- Podemos tener funciones que cambien otras funciones

- Podemos escribir funciones que proporcionen nuevos tipos de control de flujo


FUNCIONES CALLBACK

Las funciones callback (retrollamados) son funciones que se pasan a otras funciones como argumentos y son llamadas por la función en la que se pasan.

- Simplemente, las funciones callback son funciones que escribimos como argumentos en otras funciones. 

- No podemos invocar funciones callback. 

- Se invocan cuando se llama a la función principal en la que se pasaron como argumentos.

PRINCIPIOS DE LA PROGRAMACIÓN FUNCIONAL 

Hay algunos principios que debemos comprender si nuestros programas deben calificar para el estándar de programación funcional. Echemos un vistazo a esos.

- Evite mutaciones y efectos secundarios 

El primer principio de la programación funcional es evitar cambiar las cosas. Una función no debería cambiar nada, como una variable global.

Esto es muy importante porque los cambios a menudo provocan errores. Si una función cambia una variable global, por ejemplo, podría dar lugar a un comportamiento inesperado en todos los lugares donde se utiliza esa variable.

El segundo principio es que una función debe ser pura, lo que significa que no tiene efectos secundarios. En la programación funcional, los cambios que se realizan se denominan mutaciones y los resultados se denominan efectos secundarios.

Una función pura no hace ninguna de las dos. Una función pura siempre tendrá la misma salida para la misma entrada.

Si una función depende de una variable global, esa variable debe pasarse a la función como argumento. Esto nos permite obtener la misma salida para la misma entrada.

Aquí hay un ejemplo:

const edadLegalEnEEUU = 21;
const chequearEstadoLegal = (edad, edadLegal) => {
    return edad >= edadLegal ? 'Mayor de edad.' : 'Menor de edad.';
};
const johnEstado = chequearEstadoLegal(18, edadLegalEnEEUU);
johnEstado; // Menor de edad.
edadLegalEnEEUU; // 21

_________________________________________________________________________________

CLASE 8

MÉTODO EN PROGRAMACIÓN

El término "método" en el contexto de la programación se refiere a una función o procedimiento que está asociado a un objeto o clase específica. Los objetos son instancias de una clase en la programación orientada a objetos (POO). Cada objeto puede tener atributos (variables) y métodos (funciones) que definen su comportamiento y funcionalidad.

Los métodos representan las acciones o comportamientos que un objeto puede realizar. Por ejemplo, si tienes una clase "Coche", los métodos asociados a esta clase podrían ser "arrancar", "detenerse", "acelerar", "girar", etc. Cada uno de estos métodos definirá cómo se realizan esas acciones para un objeto específico de la clase "Coche".

Cuando un programa llama a un método de un objeto, el objeto realiza la acción definida por ese método. Los métodos son esenciales para la programación orientada a objetos, ya que permiten interactuar con los objetos y manipular sus datos de manera estructurada y controlada.

EL OBJETO MATH

- Math es un objeto incorporado que tiene propiedades y métodos para constantes y funciones matemáticas. No es un objeto de función.

- Cuando trabajamos con Javascript, es posible realizar gran cantidad de operaciones matemáticas de forma nativa, sin necesidad de librerías externas. Para ello, haremos uso del objeto Math, un objeto interno de Javascript que tiene incorporadas ciertas constantes y métodos (funciones) para trabajar matemáticamente.

- El objeto Math de Javascript incorpora varias constantes que podemos necesitar en algunas operaciones matemáticas. Veamos su significado y valor aproximado:

Math.E	Número de Euler	2.718281828459045

Math.LN2	Equivalente a Math.log(2)	0.6931471805599453

Math.LN10	Equivalente a Math.log(10)	2.302585092994046

Math.LOG2E	Equivalente a Math.log2(Math.E)	1.4426950408889634

Math.LOG10E	Equivalente a Math.log10(Math.E)	0.4342944819032518

Math.PI	Número PI o Π	3.141592653589793

Math.SQRT1_2	Equivalente a Math.sqrt(1/2).	0.7071067811865476

Math.SQRT2	Equivalente a Math.sqrt(2).	1.4142135623730951

Además de estas constantes, el objeto Math también nos proporciona gran cantidad de métodos o funciones para trabajar con números. Vamos a analizarlos.

MÉTODOS MATEMÁTICOS

Los siguientes métodos matemáticos están disponibles en Javascript a través del objeto Math:

 Math.abs(x)	Devuelve el valor absoluto de x.	|x|

 Math.sign(x) 	Devuelve el signo del número: 1 positivo, -1 negativo

 Math.exp(x)	Exponenciación. Devuelve el número e elevado a x.	ex

 Math.expm1(x) 	Equivalente a Math.exp(x) - 1.	ex-1

 Math.max(a, b, c...)	Devuelve el número más grande de los indicados por parámetro.

 Math.min(a, b, c...)	Devuelve el número más pequeño de los indicados por parámetro.	

 Math.pow(base, exp)	Potenciación. Devuelve el número base elevado a exp.	baseexp

 Math.sqrt(x)	Devuelve la raíz cuadrada de x.	√x

 Math.cbrt(x) 	Devuelve la raíz cúbica de x.	√3x

 Math.imul(a, b) 	Equivalente a a * b, pero a nivel de bits.	

 Math.clz32(x) 	Devuelve el número de ceros a la izquierda de x en binario (32 bits).	

 Veamos algunos ejemplos aplicados a las mencionadas funciones anteriormente:

Math.abs(-5);             // 5
Math.sign(-5);            // -1
Math.exp(1);              // e, o sea, 2.718281828459045
Math.expm1(1);            // 1.718281828459045
Math.max(1, 40, 5, 15);   // 40
Math.min(5, 10, -2, 0);   // -2
Math.pow(2, 10);          // 1024 (Equivale a 2**10)
Math.sqrt(2);             // 1.4142135623730951 (Equivale a Math.SQRT2)
Math.cbrt(2);             // 1.2599210498948732
Math.imul(0xffffffff, 7); // -7

MÉTODO Math.random()

- Uno de los métodos más útiles e interesantes del objeto Math es Math.random().

- Devuelve un número al azar entre 0 y 1 con 16 decimales.

Math.random() es un método en JavaScript que devuelve un número de punto flotante pseudoaleatorio en el rango de 0 (incluido) a 1 (excluido). Esto significa que el número generado será mayor o igual a 0 pero menor que 1. Es importante tener en cuenta que el número generado no es verdaderamente aleatorio, sino que es el resultado de un algoritmo determinista, por lo que se le llama "pseudoaleatorio".

Fórmula:

Math.random() * (max - min) + min;


es una forma común de generar un número aleatorio dentro de un rango específico, donde min y max son los límites inferiores y superiores deseados del rango, respectivamente. Desglosemos los pasos uno por uno:

Math.random(): Esta parte genera un número de punto flotante aleatorio entre 0 (incluido) y 1 (excluido). Como mencioné anteriormente, el número generado estará en el rango [0, 1).

(max - min): Esto calcula la diferencia entre el límite superior (max) y el límite inferior (min). Este valor representa el rango de números que deseas generar.

Math.random() * (max - min): Esto multiplica el número aleatorio por el rango. El resultado será un número aleatorio entre 0 (incluido) y el rango (max - min), pero aún no incluyendo el límite superior del rango (max).

Math.random() * (max - min) + min;: Por último, se suma el valor de min a la expresión para desplazar el rango hacia arriba.

---------------------------------------------------------------

FECHA Y HORA

Aprendamos un nuevo objeto incorporado de JS: Date. Este objeto almacena la fecha, la hora, y brinda métodos para administrarlas.

Por ejemplo, podemos usarlo para almacenar horas de creación o modificación, medir tiempo, o simplemente mostrar en pantalla la fecha actual.

Creación
Para crear un nuevo objeto Date se lo instancia con new Date() junto con uno de los siguientes argumentos:

new Date()
Sin argumentos – crea un objeto Date para la fecha y la hora actuales:

let now = new Date();
alert( now ); // muestra en pantalla la fecha y la hora actuales

Acceso a los componentes de la fecha

Existen métodos que sirven para obtener el año, el mes, y los demás componentes a partir de un objeto de tipo Date:

getFullYear()
Devuelve el año (4 dígitos)

getMonth()
Devuelve el mes, de 0 a 11.

getDate()
Devuelve el día del mes desde 1 a 31. Nótese que el nombre del método no es muy 
intuitivo.

getHours(), getMinutes(), getSeconds(), getMilliseconds()
Devuelve los componentes del horario correspondientes.

-----------------------------------------

No getYear(), sino getFullYear()

Algunos motores de JavaScript poseen implementado un método no estándar llamado getYear(). Este método actualmente está obsoleto. A veces devuelve un año de 2 dígitos. Por favor, nunca lo uses. Usa getFullYear() para obtener el año.